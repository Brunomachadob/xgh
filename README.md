### 1. I think therefore it's not XGH.

In XGH you don't think, you do the first thing that comes to your mind.
There's no second option, only the fastest one.

### 2. There are 3 ways of solving a problem:

- The right way;
- The wrong way;
- The XGH way, which is exactly like the wrong one but faster.

XGH is faster than any development process you know (see [Axiom 14](#14-xgh-is-not-a-fad)).

### 3. The more XGH you do, the more you need it.

For every problem solved using XGH, ~7 more are created.
And all of them will be solved using XGH.
Therefore, XGH tends to infinite.

### 4. XGH is completely reactive.

Errors only come to exist when they appear.

### 5. In XGH anything goes.

It solves the problem? It compiled? You commit and don't think about it anymore.

### 6. You commit always before updating.

If things go wrong your part will always be correct... and your colleagues will be the ones dealing with the problems.

### 7. XGH doesn't have deadlines.

Deadlines given to you by your clients are all but important.
You will *ALWAYS* be able to implement *EVERYTHING* in time (even if that means accessing the DB through some crazy script).

### 8. Be ready to jump off when the boat starts sinking. Or blame someone else.

For people using XGH someday the boat sinks.
As time passes by, the probability only increases.
You better have your resume ready for when the thing comes down. Or have someone else to blame.

### 9. Be authentic. XGH don't follow patterns.

Write code as you may want. If it solves the problem, just commit and forget about it.

### 10. There's no refactoring just rework.

If things ever go wrong just use XGH to quickly solve the problem.
Whenever the problem requires rewriting the whole software it's time
for you to drop off before the whole thing goes down (see [Axiom 8](#8-be-ready-to-jump-off-when-the-boat-starts-sinking-or-blame-someone-else)).

### 11. XGH is anarchic.

There's no need for a project manager.
There's no owner and everyone does whatever they want when the problems and requirements appear (see [Axiom 4](#4-xgh-is-completely-reactive)).

### 12. Always believe in improvement promises.

Putting `TODO` comments in the code as a promise that the code will be improved later helps the XGH developer.
Nobody will feel guilt for the shit that has been done. Sure there won't be no refactoring (see [Axiom 10](#10-theres-no-refactoring-just-rework)).

### 13. XGH is absolute.

Delivery dates and costs are absolute things. Quality is totally relative.
Never think about quality but instead think about the minimum time required to implement a solution.
Actually, don't think. Do! (see [Axiom 1](#1-i-think-therefore-its-not-xgh))

### 14. XGH is not a fad.

Scrum, XP? Those are just trends.
XGH developers don't follow temporary trends. 
XGH will always be used by those who despise quality.

### 15. XGH is not always WOP (Workaround-oriented programming).

Many WOP require smart thinking.
XGH requires no thinking (see [Axiom 1](#1-i-think-therefore-its-not-xgh)).

### 16. Don't try to row against the tide.

If your colleagues use XGH and you are the only sissy who wants to do things the right way then quit it!
For any design pattern that you apply correctly your colleagues will generate 10 times more rotten code using XGH.

### 17. XGH is not dangerous, until you try putting some order into it.

This axiom is very complex, but it says that a XGH project is always in chaos.
Don't try to put order into XGH (see [Axiom 16](#16-dont-try-to-row-against-the-tide)).
It's useless, and you'll spend a lot of precious time. 
This will make things go down even faster (see [Axiom 8](#8-be-ready-to-jump-off-when-the-boat-starts-sinking-or-blame-someone-else)).
Don't try to manage XGH as it's auto-sufficient (see [Axiom 11](#11-xgh-is-anarchic)) as it's also chaos.

### 18. XGH is your bro. But it's vengeful.

While you want it, XGH will always be at your side.
But be careful not to abandon him.
If you start something using XGH and then turn to some trendy methodology you will be fucked up.
XGH doesn't allow refactoring (see [Axiom 10](#10-theres-no-refactoring-just-rework)) and your new sissy system will collapse.
When that happens only XGH can save you.

### 19. If it's working, don't bother.

Never ever change - or even think of question - a working code.
That's a complete waste of time, even more because refactoring doesn't exist (see [Axiom 10](#10-theres-no-refactoring-just-rework)).
Time is the engine behind XGH and quality is just a meaningless detail.

### 20. Tests are for pussies.

If you ever worked with XGH you better know what you're doing.
And if you know what you're doing why test then? Tests are a waste of time.
If it compiles it's good.

### 21. Be used to the 'living on the edge' feeling.

Failure and sucess are really similar and XGH is not different.
People normally think that a project can have greater chances of failing when using XGH.
But success is just a way of seeing it.
The project failed. You learned something with it? Then for you, it was a success!

### 22. The problem is only yours when your name is on the code docs.

Never touch a class of code which you're not the author.
When a team member dies or stays away for too long the thing will go down.
When that happens use [Axiom 8](#8-be-ready-to-jump-off-when-the-boat-starts-sinking-or-blame-someone-else).

### 23. More is more.

With XGH you thrive on code duplication.
Code quality is meaningless and there's no time for code reviews or refactoring.
Time is of the essence, so copy and paste, quickly!


---


**Translation:** [banaslee](https://github.com/banaslee)